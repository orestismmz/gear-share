# Table SQL info

### Profiles

RLS status and all policies (profiles):

[
{
"schema": "public",
"table": "profiles",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "Enable read access for all users",
"command": "SELECT",
"roles": "-",
"using_expression": "true",
"with_check_expression": null
},
{
"schema": "public",
"table": "profiles",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "users can create their own profile",
"command": "INSERT",
"roles": "-",
"using_expression": null,
"with_check_expression": "((auth.uid() = id) AND (is_verified = false))"
},
{
"schema": "public",
"table": "profiles",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "users can delete own profile",
"command": "DELETE",
"roles": "authenticated",
"using_expression": "(auth.uid() = id)",
"with_check_expression": null
},
{
"schema": "public",
"table": "profiles",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "users can update own profile",
"command": "UPDATE",
"roles": "authenticated",
"using_expression": "(auth.uid() = id)",
"with_check_expression": "(auth.uid() = id)"
}
]

### Constraints (profiles):

[
{
"constraint_name": "profiles_id_fkey",
"constraint_type": "FOREIGN KEY",
"definition": "FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE"
},
{
"constraint_name": "profiles_pkey",
"constraint_type": "PRIMARY KEY",
"definition": "PRIMARY KEY (id)"
},
{
"constraint_name": "profiles_username_key",
"constraint_type": "UNIQUE",
"definition": "UNIQUE (username)"
}
]

### Indexes (profiles)

[
{
"schemaname": "public",
"tablename": "profiles",
"indexname": "profiles_pkey",
"indexdef": "CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id)"
},
{
"schemaname": "public",
"tablename": "profiles",
"indexname": "profiles_username_key",
"indexdef": "CREATE UNIQUE INDEX profiles_username_key ON public.profiles USING btree (username)"
}
]

## Listings

## RLS status + all policies (listings):

[
{
"schema": "public",
"table": "listings",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "Listings are viewable by everyone",
"command": "SELECT",
"roles": "-",
"using_expression": "true",
"with_check_expression": null
},
{
"schema": "public",
"table": "listings",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "Users can create their own listings",
"command": "INSERT",
"roles": "authenticated",
"using_expression": null,
"with_check_expression": "(auth.uid() = owner_id)"
},
{
"schema": "public",
"table": "listings",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "Users can delete their own listings",
"command": "DELETE",
"roles": "authenticated",
"using_expression": "(auth.uid() = owner_id)",
"with_check_expression": null
},
{
"schema": "public",
"table": "listings",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "Users can update their own listings",
"command": "UPDATE",
"roles": "authenticated",
"using_expression": "(auth.uid() = owner_id)",
"with_check_expression": "(auth.uid() = owner_id)"
}
]

### Constraints (listings)

[
{
"constraint_name": "listings_category_check",
"constraint_type": "CHECK",
"definition": "CHECK (category = ANY (ARRAY['diy'::text, 'sports'::text, 'outdoor'::text, 'photography'::text, 'music'::text]))"
},
{
"constraint_name": "listings_condition_check",
"constraint_type": "CHECK",
"definition": "CHECK (condition = ANY (ARRAY['new'::text, 'like_new'::text, 'good'::text, 'fair'::text, 'poor'::text]))"
},
{
"constraint_name": "listings_location_check",
"constraint_type": "CHECK",
"definition": "CHECK (location = ANY (ARRAY['amagerbro'::text, 'østerbro'::text, 'nørrebro'::text, 'vesterbro'::text]))"
},
{
"constraint_name": "listings_price_per_day_check",
"constraint_type": "CHECK",
"definition": "CHECK (price_per_day > 0::numeric)"
},
{
"constraint_name": "listings_owner_id_fkey",
"constraint_type": "FOREIGN KEY",
"definition": "FOREIGN KEY (owner_id) REFERENCES profiles(id) ON DELETE CASCADE"
},
{
"constraint_name": "listings_pkey",
"constraint_type": "PRIMARY KEY",
"definition": "PRIMARY KEY (id)"
}
]

### Indexes (listings)

[
{
"schemaname": "public",
"tablename": "listings",
"indexname": "listings_created_at_idx",
"indexdef": "CREATE INDEX listings_created_at_idx ON public.listings USING btree (created_at DESC)"
},
{
"schemaname": "public",
"tablename": "listings",
"indexname": "listings_location_idx",
"indexdef": "CREATE INDEX listings_location_idx ON public.listings USING btree (location)"
},
{
"schemaname": "public",
"tablename": "listings",
"indexname": "listings_owner_id_idx",
"indexdef": "CREATE INDEX listings_owner_id_idx ON public.listings USING btree (owner_id)"
},
{
"schemaname": "public",
"tablename": "listings",
"indexname": "listings_pkey",
"indexdef": "CREATE UNIQUE INDEX listings_pkey ON public.listings USING btree (id)"
}
]

## Bookings

### RLS Status + All policies (bookings)

[
{
"schema": "public",
"table": "bookings",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "Bookings: borrower can create",
"command": "INSERT",
"roles": "authenticated",
"using_expression": null,
"with_check_expression": "((borrower_id = auth.uid()) AND (status = 'pending'::booking_status) AND (owner_removed = false) AND (borrower_removed = false) AND (EXISTS ( SELECT 1\n   FROM listings l\n  WHERE (([l.id](http://l.id/) = bookings.listing_id) AND (l.owner_id <> auth.uid())))))"
},
{
"schema": "public",
"table": "bookings",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "Bookings: borrower can delete own pending",
"command": "DELETE",
"roles": "authenticated",
"using_expression": "((borrower_id = auth.uid()) AND (status = 'pending'::booking_status))",
"with_check_expression": null
},
{
"schema": "public",
"table": "bookings",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "Bookings: borrower can soft delete",
"command": "UPDATE",
"roles": "authenticated",
"using_expression": "(borrower_id = auth.uid())",
"with_check_expression": "((borrower_id = auth.uid()) AND (status = ANY (ARRAY['cancelled'::booking_status, 'declined'::booking_status, 'completed'::booking_status])) AND (borrower_removed = true))"
},
{
"schema": "public",
"table": "bookings",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "Bookings: borrower or owner can cancel",
"command": "UPDATE",
"roles": "authenticated",
"using_expression": "((borrower_id = auth.uid()) OR (EXISTS ( SELECT 1\n   FROM listings l\n  WHERE (([l.id](http://l.id/) = bookings.listing_id) AND (l.owner_id = auth.uid())))))",
"with_check_expression": "((status = 'cancelled'::booking_status) AND (start_date > CURRENT_DATE))"
},
{
"schema": "public",
"table": "bookings",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "Bookings: owner can approve/decline",
"command": "UPDATE",
"roles": "authenticated",
"using_expression": "(EXISTS ( SELECT 1\n   FROM listings l\n  WHERE (([l.id](http://l.id/) = bookings.listing_id) AND (l.owner_id = auth.uid()))))",
"with_check_expression": "((status = ANY (ARRAY['approved'::booking_status, 'declined'::booking_status])) AND (start_date > CURRENT_DATE))"
},
{
"schema": "public",
"table": "bookings",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "Bookings: owner can soft delete",
"command": "UPDATE",
"roles": "authenticated",
"using_expression": "(EXISTS ( SELECT 1\n   FROM listings l\n  WHERE (([l.id](http://l.id/) = bookings.listing_id) AND (l.owner_id = auth.uid()))))",
"with_check_expression": "((EXISTS ( SELECT 1\n   FROM listings l\n  WHERE (([l.id](http://l.id/) = bookings.listing_id) AND (l.owner_id = auth.uid())))) AND (status = ANY (ARRAY['cancelled'::booking_status, 'declined'::booking_status, 'completed'::booking_status])) AND (owner_removed = true))"
},
{
"schema": "public",
"table": "bookings",
"rls_enabled": true,
"rls_forced": false,
"policy_name": "Bookings: read relevant",
"command": "SELECT",
"roles": "authenticated",
"using_expression": "((borrower_id = auth.uid()) OR (EXISTS ( SELECT 1\n   FROM listings l\n  WHERE (([l.id](http://l.id/) = bookings.listing_id) AND (l.owner_id = auth.uid())))))",
"with_check_expression": null
}
]

### Constraints (bookings):

[
{
"constraint_name": "bookings_status_check",
"constraint_type": "CHECK",
"definition": "CHECK (status = ANY (ARRAY['pending'::booking_status, 'approved'::booking_status, 'declined'::booking_status, 'cancelled'::booking_status, 'completed'::booking_status]))"
},
{
"constraint_name": "bookings_valid_date_range",
"constraint_type": "CHECK",
"definition": "CHECK (end_date >= start_date)"
},
{
"constraint_name": "bookings_no_overlap",
"constraint_type": "EXCLUDE",
"definition": "EXCLUDE USING gist (listing_id WITH =, daterange(start_date, end_date, '[]'::text) WITH &&) WHERE (status = ANY (ARRAY['approved'::booking_status, 'completed'::booking_status]))"
},
{
"constraint_name": "bookings_borrower_id_fkey",
"constraint_type": "FOREIGN KEY",
"definition": "FOREIGN KEY (borrower_id) REFERENCES profiles(id) ON DELETE CASCADE"
},
{
"constraint_name": "bookings_listing_id_fkey",
"constraint_type": "FOREIGN KEY",
"definition": "FOREIGN KEY (listing_id) REFERENCES listings(id) ON DELETE CASCADE"
},
{
"constraint_name": "bookings_pkey",
"constraint_type": "PRIMARY KEY",
"definition": "PRIMARY KEY (id)"
}
]

### All non-internal triggers on `public.bookings` (definitions) (bookings)

[
{
"trigger_name": "trg_bookings_only_status_and_softdelete_updatable",
"enabled_state": "disabled",
"trigger_definition": "CREATE TRIGGER trg_bookings_only_status_and_softdelete_updatable BEFORE UPDATE ON bookings FOR EACH ROW EXECUTE FUNCTION bookings_only_status_and_softdelete_updatable()"
},
{
"trigger_name": "trg_prevent_booking_price_edits",
"enabled_state": "enabled",
"trigger_definition": "CREATE TRIGGER trg_prevent_booking_price_edits BEFORE UPDATE OF price_per_day_at_booking, total_price ON bookings FOR EACH ROW EXECUTE FUNCTION prevent_booking_price_edits()"
},
{
"trigger_name": "trg_set_booking_prices",
"enabled_state": "enabled",
"trigger_definition": "CREATE TRIGGER trg_set_booking_prices BEFORE INSERT OR UPDATE OF start_date, end_date ON bookings FOR EACH ROW EXECUTE FUNCTION set_booking_prices()"
}
]

### Triggered functions for triggers on `public.bookings` (names + args) (bookings)

[
{
"trigger_name": "trg_bookings_only_status_and_softdelete_updatable",
"function_schema": "public",
"function_name": "bookings_only_status_and_softdelete_updatable",
"function_oid": 34681,
"function_args": ""
},
{
"trigger_name": "trg_prevent_booking_price_edits",
"function_schema": "public",
"function_name": "prevent_booking_price_edits",
"function_oid": 33434,
"function_args": ""
},
{
"trigger_name": "trg_set_booking_prices",
"function_schema": "public",
"function_name": "set_booking_prices",
"function_oid": 33432,
"function_args": ""
}
]

### Trigger function SQL bodies (bookings)

[
{
"trigger_name": "trg_bookings_only_status_and_softdelete_updatable",
"function_schema": "public",
"function_name": "bookings_only_status_and_softdelete_updatable",
"function_definition": "CREATE OR REPLACE FUNCTION public.bookings_only_status_and_softdelete_updatable()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n  if (new.listing_id       is distinct from old.listing_id)       or\n     (new.borrower_id      is distinct from old.borrower_id)      or\n     (new.start_date       is distinct from old.start_date)       or\n     (new.end_date         is distinct from old.end_date)         or\n     (new.created_at       is distinct from old.created_at)       then\n    raise exception 'Only status/owner_deleted/borrower_deleted can be updated on bookings';\n  end if;\n\n  return new;\nend;\n$function$\n"
},
{
"trigger_name": "trg_prevent_booking_price_edits",
"function_schema": "public",
"function_name": "prevent_booking_price_edits",
"function_definition": "CREATE OR REPLACE FUNCTION public.prevent_booking_price_edits()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n  if new.price_per_day_at_booking <> old.price_per_day_at_booking\n     or new.total_price <> old.total_price then\n    raise exception 'Price fields cannot be edited';\n  end if;\n  return new;\nend;\n$function$\n"
},
{
"trigger_name": "trg_set_booking_prices",
"function_schema": "public",
"function_name": "set_booking_prices",
"function_definition": "CREATE OR REPLACE FUNCTION public.set_booking_prices()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\ndeclare\n  v_days integer;\nbegin\n  -- Lock price only when creating the booking\n  if tg_op = 'INSERT' then\n    select l.price_per_day\n      into new.price_per_day_at_booking\n    from public.listings l\n    where [l.id](http://l.id/) = new.listing_id;\n\n    if new.price_per_day_at_booking is null then\n      raise exception 'Listing % not found', new.listing_id;\n    end if;\n  end if;\n\n  -- Inclusive day count: end - start + 1 (18->20 = 3 days)\n  v_days := (new.end_date - new.start_date) + 1;\n  if v_days <= 0 then\n    raise exception 'Invalid date range';\n  end if;\n\n  -- Total always from snapshot price (won’t change if listing price changes later)\n  new.total_price := new.price_per_day_at_booking * v_days;\n\n  return new;\nend;\n$function$\n"
}
]

### Indexes (bookings)

[
{
"schemaname": "public",
"tablename": "bookings",
"indexname": "bookings_borrower_id_idx",
"indexdef": "CREATE INDEX bookings_borrower_id_idx ON public.bookings USING btree (borrower_id)"
},
{
"schemaname": "public",
"tablename": "bookings",
"indexname": "bookings_created_at_idx",
"indexdef": "CREATE INDEX bookings_created_at_idx ON public.bookings USING btree (created_at DESC)"
},
{
"schemaname": "public",
"tablename": "bookings",
"indexname": "bookings_listing_id_idx",
"indexdef": "CREATE INDEX bookings_listing_id_idx ON public.bookings USING btree (listing_id)"
},
{
"schemaname": "public",
"tablename": "bookings",
"indexname": "bookings_no_overlap",
"indexdef": "CREATE INDEX bookings_no_overlap ON public.bookings USING gist (listing_id, daterange(start_date, end_date, '[]'::text)) WHERE (status = ANY (ARRAY['approved'::booking_status, 'completed'::booking_status]))"
},
{
"schemaname": "public",
"tablename": "bookings",
"indexname": "bookings_pkey",
"indexdef": "CREATE UNIQUE INDEX bookings_pkey ON public.bookings USING btree (id)"
},
]